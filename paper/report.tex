\documentclass[12pt]{report}
\usepackage[pdftex]{graphicx}
\usepackage{url}
\usepackage{amsmath}
\usepackage{listings}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor auto-nomous}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Design of an Attitude and Heading Reference Sensor}
\author{Patrick Hickey\\pat@moreproductive.org}
\input{./title.tex}

\begin{abstract}
This paper describes the design of an Attitude and Heading Reference Sensor (AHRS), which measures rotational orientation relative to north and down. 
The design uses 3-axis accelerometer, magnetometer, and rate gyro sensors. 
I will discuss the selection and construction of the sensor hardware, design and implementation of a Kalman filter for sensor fusion, and the test of both the sensor hardware and software.
\end{abstract}


\section{Problem Description}

The goal of this project was to design and build sensor hardware and software that would determine the angular orientation and angular rotation rate of the sensor relative to the earth frame, IE. North, East, and Down. I selected sensor integrated circuits (ICs) which determine, on three axes, body acceleration, body rotation rate, and relative magnetic field. These three sensors (accelerometer, rate gyro, and magnetometer) provide a total of nine measurements. 

An algorithm is required to convert these nine measurements into an expression of angular orientation and angular rate (the derivative, with respect to time, of angular orientation). Angular orientation of a body has three degrees of freedom, as does angular rate. The conversion from measurement space to estimate space (a pair of angular orientation estimate and angular rate estimate) is nonlinear and uses a four-dimensional vector called a quaternion to describe the three-dimensional angular orientation. This is to say, a big part of the problem is ensuring the correctness of this difficult conversion process.   

I selected a well-known algorithm which implements a Quaternion Kalman Filter. This provides an state estimate using the four-dimensional quaternion vector, and an additional three-dimensional rotational rate vector. I needed to implement that software so that I could test it for correctness and use it to determine the orientation of an actual sensor. This software was to be used in an actual model aircraft autopilot system, so it must meet requirements for reliability and soft real-time performance.

\subsection{Application}

As part of my role on the Rutgers Autonomous Aircraft Team, I've been working on a model aircraft autopilot system based on a single board computer which runs Linux \footnote{For more information on this project, see \url{http://moreproductive.org/autopilot/}}. I implemented the control, navigation, and telemetry software in C using standard Linux system calls and threads. I used dedicated hardware for real-time tasks, for example, a microcontroller-based servo controller connected via USB ensures proper servo control despite irregular communication intervals from the computer. 
By using helper threads for input and output, we can be reasonably sure the main control loop will run at close to 60Hz. This is considered ``soft'' real-time.

The sensor software needs to cooperate with the soft real-time main control loop. In order to stabilize a fixed-wing aircraft, we need to update the main control loop's orientation estimate at at least 30Hz, preferably at 60Hz. So the sensor hardware must provide new measurements at a rate exceeding 30Hz, a complete measurement every 33ms. The sensor filtration software must complete computation in much less than a measurement period as not to dominate the CPU. Lets consider a target time of 500us per computation.

\subsection{Use of Haskell}

The sensor software I describe in this paper is typically implemented in a low level language such as C or C++ in order to give the programmer explicit control over memory allocation and input-output (IO) calls. In fact, open source implementations of functionally similar software is available. Similarly, there are a lot of existing resources for Matlab, which is a strong platform for simulation and plotting. However, the Matlab language is not as powerful as C or C++, and is of limited use testing with actual hardware. 

I decided to write the filter software using Haskell. Haskell is a purely functional language with a powerful type system, and is not typically used for soft real-time applications. However, I believe Haskell is well suited for writing algorithms because it can express mathematical concepts elegantly, and often transparently. It is often possible to reason about Haskell code in the exact same way as mathematics. This results in code which is code more readable and more easily modified. 



\section{Theoretical Basis}

The theoretical basis for this paper has been primarily drawn from -- cite dchoukrouns paper. I hope this section provides a clear explanation of how that theory applies to this project.

\subsection{Measurement Vectors}
Because the sensors are fixed to the frame (\emph{body}) we're estimating the orientation, accelerometer and magnetometer provide us with vector measurements in the body frame. We denote body frame vectors with $b_x$. The expected vector of that measurement in the global frame is $g_x$. For example, the expected global frame acceleration $g_a = \begin{bmatrix} 0 & 0 & -1\end{bmatrix} $ in units normalized to $1g$ ($9.81m/s^2$)

By comparing a body frame vector to the global frame vector, we can find a rotation which transforms the global frame into the body frame. We call this the orientation estimate.  

\subsubsection{Accelerometer Measurement}

An accelerometer measures force exerted by a small test mass against a beam connected to the sensor body. The current generation of MEMS accelerometers uses etched silicon to build the test mass and beam structure, and measures the capacitance between the test mass and sensor body to determine the beam deflection. Since an accelerometer can only measure deflection, and therefore acceleration, in one direction, we use three separate sensors oriented to measure acceleration along three orthogonal axes. These three separate measured accelerations ($a_x, a_y, a_z$) can be considered as a three dimensional vector 
\begin{equation} \label{eq:defa}
  a = \begin{bmatrix}a_x&a_y&a_z \end{bmatrix}
\end{equation}

According to Newton's second law, $F = m a$ , the force on a body will be directly proportional to the acceleration of the body. When we consider a small test mass $m_t$ on a beam, and the system is at rest, the mass will exert a force $F_g = m_t g_b$, where $g$ is the acceleration due to gravity in the body frame. A body acceleration ab will exert a force $F_a = m_t a_b$. The sensor measures the sum of these two forces, so for any $F = F_g + F_a = m_t ( g_b + a_b )$. Because $m_t$ is constant, we can define the scaled measurement $a$ as 
\begin{equation} \label{eq:defza}
  a = \frac{F}{m_t} = g_b + a_b
\end{equation} 
 
In this application we're interesting in estimating $b_a$ in order to find the vector, in the body frame, which points straight down in the world frame. We include a measurement noise vector $\delta_a$, and find measurement $z_b$ as
\begin{equation} \label{eq:findgb}
  z_a = b_a + a_b + \delta_a
\end{equation}

On a body such as an aircraft, where accelerations $a_b$ may come from any direction at any time, we consider $a_b$ to be a zero-mean Gaussian random vector with a covariance matrix 
\begin{equation} \label{eq:Qa}
  Q_a = \begin{pmatrix} \sigma_a^2 & 0 & 0 \\
	                      0 & \sigma_a^2 & 0 \\ 
	                      0 & 0 & \sigma_a^2 \end{pmatrix} 
\end{equation}

Covariance matrix $Q_a$ will be used in the measurement model of the Kalman Filter. We typically estimate a value for $\sigma_a$ to be between 2$g$ and 4$g$ for airborne applications. Since $\delta_a$ will be zero-mean and have a small variance compared to $a_b$ we can neglect it.

\subsubsection{Magnetometer Measurement}

A magnetometer measures the magnitude magnetic field in one direction. I refer the interested reader to ... for a physical explanation of magnetometer sensors. The three separate measured magnetic field magnitudes ($m_x, m_y, m_z$) are considered as a three dimensional vector
\begin{equation} \label{eq:defb}
  m = \begin{bmatrix} m_x & m_y & m_z \end{bmatrix}
\end{equation}

The measured magnetic field $z_m$ will be the sum of three vectors: the natural magnetic field of the earth in the body frame $b_m$, the magnetic field of the body $m_s$, and measurement noise $\delta_m$.
\begin{equation} \label{eq:zm}
  z_m = b_m + m_s + \delta_m
\end{equation}
In this filter we assume the magnetic field of the body $m_s$ to be constant\footnote{Electrical and mechanical components which emit a changing electromagnetic field, such as DC motors and switching power supplies, will cause trouble.}. We will estimate $m_s$ for the particular body the sensor is installed in. Measurement noise $\delta_m$ will be considered a zero-mean Gaussian random vector with covariance matrix
\begin{equation} \label{eq:Qm}
  Q_m = \begin{pmatrix} \sigma_m^2 & 0 & 0 \\
	                      0 & \sigma_m^2 & 0 \\ 
	                      0 & 0 & \sigma_m^2 \end{pmatrix} 
\end{equation}

We will estimate $\sigma_m$ from a long sequence of samples taken with the filter hardware at rest.

The earth's magnetic field, in the global frame ($g_m$), will point towards magnetic north when projected onto a horizontal plane. (talk about magnetic field strength, magnetic declination angle here)


\subsubsection{Rate Gyro Measurement}

A rate gyro measures the rotation rate of a body about a single axis. We use three orthogonal rate gyros to estimate the rotational rate of the body, considered as a vector
\begin{equation} \label{eq:omega}
	\omega = \begin{bmatrix} \omega_x & \omega_y & \omega_z \end{bmatrix}
\end{equation}
The measurement $z_\omega$ can be considered as
\begin{equation} \label{eq:zomega}
	z_\omega = \omega + \Delta_\omega + \delta_\omega
\end{equation}
where rate gyro zero offset $\Delta_\omega$ is the constant vector output when the sensor body is at rest,
and measurement noise $\delta_\omega$ is a zero-mean Gaussian random vector with covariance matrix
\begin{equation} \label{eq:Qomega}
	Q_\omega = \begin{pmatrix} \sigma_\omega^2 & 0 & 0 \\
	                  ]    0 & \sigma_\omega^2 & 0 \\ 
	                      0 & 0 & \sigma_\omega^2 \end{pmatrix} 
\end{equation}

In reality, zero offset $\Delta_\omega$ may drift with time and change in temperature. Compensation for this gyro drift is outside the scope of this paper, but has been solved in --cite Dacrons better paper.

\subsection{Quaternion Representation}

There are a wide variety of resources which formally describe quaternions and their use in describing spatial rotations. I will give an overview of the most useful properties which will be used in this work.

A quaternion is a complex number with three imaginary components, $i,j,k$, which are defined such that $i^2 = j^2 = k^2 = ijk = -1$. Quaternions span a four-dimensional real-numbered space where a quaternion $a + b i + c j + d k$ can be considered as a vector $\begin{bmatrix}a & b & c & d \end{bmatrix}$. 

Quaternion multiplication is a non-commutative operation: $q_1 q_2$ is not equal to $q_2 q_1$ for all quaternions $q_1, q_2$. This property is useful because spatial rotation is a non-commutative operation as well.

The set of unit quaternions, all $q$ where $ ||q|| = 1$, are used to represent spatial rotations. For every unit quaternion $q$ 
there exists a unit vector $\mathbf{v} = \begin{bmatrix} v_x & v_y & v_z \end{bmatrix}, ||v|| = 1$ 
and an angle $\theta \in [-\pi, \pi]$ where 
$q = \begin{bmatrix} \cos (\theta/2) & v_x \sin (\theta/2) & v_y \sin (\theta/2) & v_z \sin (\theta/2)\end{bmatrix}$. The quaternion formed in this represents a spatial rotation about axis $\mathbf{v}$ of angle $\theta$. 
From this angle-axis notation, we can see that $q$ and $-q$ represent the same spatial rotation. 

The inverse quaternion $q^{-1} = a - bi - cj - dk$ of a unit quaternion $q$ represents the inverse rotation $q$. We can visualize this as the same angle of rotation $\theta$ about an inverted axis $\mathbf{v}$.

I refer the reader to --citations for more detailed information.

\section{Hardware}
\subsection{Sensors}
In order to simplify the design of the sensor module, I selected two digital ICs which contain all of the sensing elements and analog to digital interfaces on board. 
Both digital devices selected require no external passive or active components aside from bypass capacitors. Analog sensors, by comparison, often require several amplifier and filter components per channel, and often, for high resolution sensing applications, a discrete analog to digital converter (ADC) IC. In addition, analog ICs generally require an isolated ``quiet'' power and ground from digital ICs. 

\subsubsection{Three-axis Accelerometer and Magnetometer}
ST Micro's LSM303DLH, a three-axis accelerometer and magnetometer, was selected for this project. A single 6x6mm surface mount package contains both an accelerometer and magnetometer module, each with their own analog to digital converters and two-wire (I2C) serial interface. 

The three-axis accelerometer has a maximum range of ... and ... bits (... g) of resolution. The maximum sample rate is ... samples per second.

The accelerometer module includes a self-test functionality, which ...
I've implemented a boot time self-test in the embedded code.

The three-axis magnetometer has a maximum measurement range of  and ... bits (... unit) of resolution. The maximum sample rate is ... samples per second. 

The magnetometer module includes a self-test functionality, which ...
I've implemented a boot time self-test in the embedded code.

The LSM303DLH is presently (May 2010) unreleased by ST Micro. I would like to thank ST Micro for donating an evaluation board to my project. The evaluation board provided 0.1" pitch headers, and connected both the accelerometer and magnetometer module's I2C bus to a common pair of pins. It also provides a configurable interrupt output pin for both the accelerometer and magnetometer module. The board takes 3.3v power and ground.

% should include a photograph, citation

\subsubsection{Three-axis Rate Gyro}

Invensense's ITG-3200, a three-axis rate gyro, was selected for this project. A 4x4mm surface mount package contains three gyro axes, analog to digital converters, and a two-wire (I2C) serial interface. It has a full scale range of $\pm 2000$ degrees per second (deg/s) and 16 bits (14.375 LSB/deg/s) of resolution. The maximum sample rate is ... samples per second. Because the rate gyro is a MEMS device, it is important that the device is isolated from severe shocks, such as drops, which could cause internal damage.

The ITG-3200 was released by Invensense in April 2010 and is presently their flagship digital sensor. I would like to thank Invensense for donating an evaluation board to my project. The ITG-3200 was provided on an evaluation board with 0.1" pitch headers. It requires a pair of signals for I2C, an optional interrupt output signal, and 3.3v power and ground. The optional interrupt output signal can be configured to signal when an analog to digital conversion is complete.

% should include a photograph, citation

\subsection{Microcontroller}
A microcontroller was required to interface with the three sensor modules on a single I2C bus, perform boot-time configuration and self-test, and transfer measurments to a PC. I selected a Sparkfun Arduino Pro Mini board, a small 0.1" pitch pin header breakout board based on a 3.3v Atmel AtMega328 microcontroller. The AtMega328 provides a single UART and single I2C peripheral. 

The sensor board connects to the host computer with an FTDI serial to USB converter. The FTDI converter also provides 3.3v power to the board.

% should include a photograph, citation

\subsection{Construction}

Because each sensor evaluation board used 0.1" pitch pins, I was able to use a 0.1" pitch protoboard and female pin headers to build a prototype sensor. The assembled sensor prototype is 2.5" x 4.5" x 0.75" in outer dimensions. To prevent electrostatic discharge and physical damage, it is velcroed inside a protective cardboard box with a lining of stiff anti-static foam. 

% picture

A schematic drawing is provided in the appendix. % do this

\lstset{language=C++,basicstyle=\ttfamily}
\section{Embedded Software}
The code described in this section can be found at \url{http://github.com/pchickey/p4l-ahrs}. It is built using the open source Arduino IDE, which can be found at \url{http://arduino.cc}.

\subsection{Requirements}
The embedded software primarily needs to send the measurments read from the I2C bus to the host computer on its 
UART\footnote{Universal Asynchronous Receive and Transmit; the receive/transmit method used by many serial protocols including RS232} 
interface. Each sensor has a number of configuration registers which are accessed through the I2C interface which need to be 

\subsection{Sensor Communication}

The communication protocol for each sensor is detailed in their data sheets, and I will not discuss them in depth here. The basic unit of interface is register read and register write. Some registers (for example, the latest measurement) are read-only, and reads may effect the state of the device. For example, a read of a register measurement on the ITG-3200 will clear the ``new measurement available'' flag on another register.   

Read Register and Write Register commands both block for nontrivial amounts of time.
\lstset{language=C++,basicstyle=\ttfamily}
From i2c\_registers.pde
\begin{lstlisting}
#include <Wire.h>
char i2cReadRegister(int i2c_device, 
                     char i2c_register)
{
  Wire.beginTransmission(i2c_device);
  Wire.send(i2c_register);
  Wire.endTransmission();
  Wire.requestFrom(i2c_device, 1);
  return Wire.receive();  
}
void i2cReadRegisterSequential(int i2c_device, 
                               char i2c_register, 
                               int len, 
                               char * buf)
{
  Wire.beginTransmission(i2c_device);
  Wire.send(i2c_register);
  Wire.endTransmission();
  Wire.requestFrom(i2c_device, len);
  int ii;
  for(ii = 0; ii < len; ii++)
    buf[ii] = Wire.receive();
  return;
}
void i2cWriteRegister(int i2c_device, 
                      char i2c_register, 
                      char value)
{
  Wire.beginTransmission(i2c_device);
  Wire.send(i2c_register);
  Wire.send(value);
  Wire.endTransmission();
}  
\end{lstlisting}

The \lstinline$Wire$ library is provided by the Arduino IDE.  The \lstinline$Wire$ object is instantiated as the interface to the single I2C peripheral\footnote{For more information on the I2C bus, see ...} on the AtMega chip. The peripheral will control the bus state and provide byte-at-a-time synchronous transmit and receive. 

Note that \lstinline$beginTransmission(int)$, \lstinline$send(char)$, and \lstinline$requestFrom(int, int)$ only return after 8 bits have been sent on the I2C bus. At a bit rate of 100kHz we can expect this to take 80$\mu$s (0.08ms). A call to \lstinline$receive()$ will not return until one byte has been received on the bus. If the slave device responds immediately, this will only take 80$mu$s, but could possibly take longer if the slave device misbehaves and holds the bus in ``wait to receive'' state.
\begin{lstlisting}
void i2cWriteWithCheck(int i2c_device, char i2c_register, 
        char value, char* name)
{
  i2cWriteRegister(i2c_device, i2c_register, value);
  char check = i2cReadRegister(i2c_device, i2c_register);
  if (check != value)
  {
    Serial.print("$DEBUG,");
    Serial.print(name);
    Serial.print(" config appears unsuccessful.");
    Serial.print("expected ");
    Serial.print(int(value));
    Serial.print(" read ");
    Serial.println(int(check));
  }
}
\end{lstlisting}
In the boot configuration of sensors, I use a wrapper on \lstinline$ i2cWriteRegister $ which confirms a write was successful. Unsuccessful writes usually indicate the sensor is malfunctioning.

% calculate best-case blocking time based on bus bitrate (100kbps?)

\subsection{Host Computer Communication}
A simple serial protocol, based on NMEA-style sentences (cite), is defined for communication with the host computer. The grammar for these sentences is \\
\emph{Sensor} := ``M" $|$ ``A" $|$ ``G" \\
\emph{Value} := ``-32768" $|$ ``-32767" $|$ ... $|$ ``-1" $|$ ``0" $|$ ``1" $|$ ... $|$ ``32767" \\
\emph{Sentence} := ``\$'' \emph{Sensor} ``,'' \emph{Value} ``,'' \emph{Value} ``,'' \emph{Value} ``$\backslash$r$\backslash$n'' \\
where the \emph{Value}s in \emph{Sentence} are the (x,y,z) axis measurments, in that order.

\subsection{Arduino Environment}
The Arduino environment is an IDE, C/C++ compiler, and collection of libraries for AtMega328 and similar Atmel AVR microcontrollers. It provides a high level interface to the hardware and is suitable for rapid prototype development. 

The timing and logic requirements of the I2C and UART interfaces are handled in hardware, and the Arduino environment provides a library for blocking read and write operations on both of these interfaces. 

On reset\footnote{The most common way to program AVR and similar micro controllers is unsupervised by any kernel, therefore ``bare metal''. Essentially, on power on a boot loader checks for new firmware over the serial port, and if none is found, passes control to a single entry point. The C linker will choose \lstinline$main()$ unless told otherwise. This bare metal code can only be superseded by interrupt service routines.}
, the Arduino environment will initialize and call \lstinline$void setup()$. This code runs once and should setup all of the interfaces which will remain the same throughout execution. The setup code then initializes the configuration registers of the sensor devices, performs sanity checks of those registers to ensure successful writes, and performs the self-test of the magnetometer and accelerometer device. 
\subsubsection{p4l\_ahrs.pde}
\begin{lstlisting}
void setup()
{
  // Serial busses
  Serial.begin(115200); // to computer
  Wire.begin(); // master device on i2c bus
  
  // Status pins
  pinMode(gyro_pin, INPUT);
  pinMode(mag_pin, INPUT);
  pinMode(acc_pin, INPUT);

  // Configure Accellerometer
  //---------------------------------

  // Configure the Accellerometer measurment rate
  i2cWriteWithCheck(ACC_ADDR, ACC_CTL1, 
    ACC_CTL1_NORMALMODE | ACC_CTL1_50HZ | ACC_CTL1_XYZENABLE, 
    "acc_ctl1 50hz xyz-enable");

  // Set Accellerometer measurment scale to +-4G
  i2cWriteWithCheck(ACC_ADDR, ACC_CTL4, ACC_CTL4_SCALE_4G, 
    "acc_ctl4 scale +-4g"); 

  // Configure Magnetometer
  // ------------------------------------

  // Configure the Magnetometer measurment rate
  i2cWriteWithCheck(MAG_ADDR, MAG_CRA, MAG_CRA_75HZ, 
    "mag cra 75HZ");

  // Configure the Magnetometer gain
  i2cWriteWithCheck(MAG_ADDR, MAG_CRB, MAG_CRB_GAIN4_0, 
    "mag crb gain4.0");

  // Perform Magnetometer Self Test
  // ---------------------------------------
  magSelfTest();
  delay(100);
  magSelfTest();

  // Reset testing configuration
  i2cWriteWithCheck(MAG_ADDR, MAG_CRA, 
    MAG_CRA_75HZ | MAG_CRA_NORMAL, "mag_cra 75hz");

  // Configure the Magnetometer Conversion Mode - Continuous
  i2cWriteWithCheck(MAG_ADDR, MAG_MR, MAG_MR_CONTINUOUS, 
    "mag mr continuous");
  Serial.println("Exiting Magnetometer Self Test");

  // Configure Rate Gyro
  // ------------------------------------------
  // Sample Rate Divider: 1khz / (divider + 1). 
  // 50hz means divider should be 19
  i2cWriteWithCheck(GYRO_ADDR, GYRO_SMPLRT_DIV, 19, 
    "gyro sample rate divider 19");
  
  // Internal Low Pass filter: 
  // 1Khz sample rate, 98Hz bandwidth
  // Full Scale: +-2000deg/sec
  i2cWriteWithCheck(GYRO_ADDR, GYRO_DLPF_FS, 
    GYRO_FS_2000 | GYRO_DLPF_98, "gyro dlpf 98 fs 2000");
  
  // Interrupt Configuration:
  // Active High (default)
  // Push-Pull (default)
  // Latch mode
  // Clear on Any register read
  // Trigger on Data Ready
  i2cWriteWithCheck(GYRO_ADDR, GYRO_INT_CFG, 
    GYRO_INT_MODE_LATCH | GYRO_INT_CLEAR_ANY | 
      GYRO_INT_CFG_DATA_RDY,
    "gyro interrupt configuration");

  // Power Managment:
  // Get clock from X axis gyro
  i2cWriteWithCheck(GYRO_ADDR, GYRO_PWR, 
    GYRO_PWR_CLK_GX_REF, 
    "gyro clock configuration");
 
\end{lstlisting}

Once the \lstinline$setup$ routine has returned, the Arduino environment will call \lstinline$void loop()$ in an endless loop. This code performs reads of any available sensor measurement, and prints the result to the serial port. The \lstinline$NewData()$ predicates are function calls which check the I2C status register on the sensor to see if a measurment is complete.

\begin{lstlisting}
void loop()
{
  if(accNewData())
  {
    accReadAndConvert();
    accSend();
  }
  if(magNewData())
  {
    magReadAndConvert();  
    magSend();
  }  
  if(gyroNewData())
  {
    gyroReadAndConvert();
    gyroSend();
  }
}
\end{lstlisting}

\lstinline$accNewData$ is a representative predicate:
\subsubsection{ST\_LSM303\_i2c.pde}
\begin{lstlisting}
bool accNewData(void)
{
  char stat = i2cReadRegister(ACC_ADDR, ACC_STAT);
  if (stat & ACC_STAT_XYZDA)
    return true;
  else return false;
}
\end{lstlisting}

As mentioned previously, the magnetometer self test is nontrivial.
\begin{lstlisting}
void magSelfTest(void)
{
  Serial.println("$DEBUG,Entering Magnetometer Self Test");
  magReadAndConvert(); // clear any LOCK state
  // Trigger a Positive Bias self test
  Serial.println(
    "triggering magnetic self test, positive bias");
  i2cWriteRegister(MAG_ADDR, 
    MAG_CRA, MAG_CRA_75HZ | MAG_CRA_POSBIAS);
  i2cWriteWithCheck(MAG_ADDR, MAG_MR, 
    MAG_MR_SINGLE, "mag mr single");
  delay(100);
  magReadAndConvert();

  Serial.print("$DEBUG,mag x nominal 270 test ");
  Serial.println(mag_x);
  Serial.print("$DEBUG,mag y nominal 270 test ");
  Serial.println(mag_y);
  Serial.print("$DEBUG,mag z nominal 255 test ");
  Serial.println(mag_z);  
  float mag_deviation = sqrt( 
    (mag_x - 270)*(mag_x - 270) + 
    (mag_y - 270)*(mag_y - 270) +
    (mag_z - 255)*(mag_z - 255) );

  Serial.print(
    "$DEBUG,positive bias self test deviation magnitude ");
  Serial.println(mag_deviation);  

  // Trigger a Negative Bias self test
  Serial.println(
    "triggering magnetic self test, negative bias");
  i2cWriteRegister(MAG_ADDR, MAG_CRA, 
    MAG_CRA_75HZ | MAG_CRA_NEGBIAS);
  i2cWriteWithCheck(MAG_ADDR, MAG_MR, 
    MAG_MR_SINGLE, "mag mr single");
  delay(100);
  magReadAndConvert();

  Serial.print("$DEBUG,mag x nominal -270 test ");
  Serial.println(mag_x);
  Serial.print("$DEBUG,mag y nominal -270 test ");
  Serial.println(mag_y);
  Serial.print("$DEBUG,mag z nominal -255 test ");
  Serial.println(mag_z);
  mag_deviation = sqrt( 
    (mag_x + 270)*(mag_x + 270) + 
    (mag_y + 270)*(mag_y + 270) +
    (mag_z + 255)*(mag_z + 255) );
  Serial.print(
    "$DEBUG,negative bias self test deviation magnitude ");
  Serial.println(mag_deviation);  
  
  return;
}
\end{lstlisting}

\section{Filtration Software}
The filtration software was implemented in Haskell. The code may be found on Github at \url{http://github.com/pchickey/hs-qkf/}
\lstset{language=Haskell}
\subsection{Algorithm Selection}
I based the algorithm of Daniel Choukroun's ``A Novel Quaternion Kalman Filter" (cite). The paper defines an algorithm for using both vector (accelerometer and magnetometer) and derivative (rate gyro) measurments optimally. Notably, it updates a quaternion state estimate by finding a Kalman filter observation matrix $H$ which relates body-frame vector measurments to the rotational frame estimate.

I used James Deibel's "..." (cite) as a reference source for converting angular representations of orientation to quaternion represent ions, and vice versa. 

\subsection{Implementation of Filter}

\subsubsection{Quaternion.hs}
I define the \lstinline$Quat$ type in a module which is used by several others. This provides standard accessors, mapping quaternion components names to their element as a \lstinline$Vector D4 Double$.
\begin{lstlisting}
module Quaternion where
import Numeric.LinearAlgebra.Static
type Quat = Vector D4 Double

-- Quaternion accessor convention:
-- In the James Deibel paper, quaternions 
--    are [re i j k] ordered; 
-- type Quat used by module Qkf is [i j k re] ordered.
-- Therefore, use these accessors for the 
--   component within this program

-- Real component
q0 :: Quat -> Double
q0 = (@>3) 
-- i component
q1 :: Quat -> Double
q1 = (@>0)
-- j component
q2 :: Quat -> Double
q2 = (@>1) 
-- k component
q3 :: Quat -> Double
q3 = (@>2) 
\end{lstlisting}

\subsubsection{Qkf.hs}
The quaternion Kalman filter is implemented in a single Haskell module.
\begin{lstlisting}

module Qkf where
-- 9 out of 10 computer scientists recommend hmatrix-static
import Numeric.LinearAlgebra.Static
import Quaternion
\end{lstlisting}


The \lstinline$Numeric.LinearAlgebra.Static$ module, distributed on hackage as \emph{hmatrix-static}\footnote{\url{http://hackage.haskell.org/package/hmatrix-static}. N.B. hmatrix-static 0.3 is only compatible with ghc-6.10 at the time of this writing.}, 
is a matrix library which makes it possible to type-check matrix operations based on the dimensions of their operands at compile time. This helps ensure code correctness and eliminates a subset of runtime errors.

The \lstinline$Quaternion$ module has been defined above.

\begin{lstlisting}
-- for deltaT and so on
type Time = Double
-- vec first {i j k}, then re
type QuatCovMat = Matrix (D4, D4) Double
-- Defined in paper, but we don't use it?
type AttitudeMat = Matrix (D3, D3) Double
-- All 3-space Measurments are zero-mean
type MeasurmentCovMat = Matrix (D3, D3) Double
type RateCovMat = Matrix (D3, D3) Double
-- 3-space vectors for acc,mag
type BodyVec = Vector D3 Double
type RefVec = Vector D3 Double
-- 3-space angular rate, measured in Body frame
type AngularRate = Vector D3 Double
-- Observations are of form 0 = Hnot*q
type ObservationMat = Matrix (D4,D4) Double
-- Observation noise maps 3space to quat space
type ZetaMat = Matrix (D4,D3) Double
-- Translate qspace to qspace
type TransitionMat = Matrix (D4,D4) Double

\end{lstlisting}

I define types for every particular matrix and vector used in the filter. This makes code more readable because the type signature is more specific. 

\begin{lstlisting}
data FilterState = 
  FilterState{ q :: Quat
             , p :: QuatCovMat } deriving( Show, Eq )

data RateEstimate = 
  RateEstimate{ omega   :: AngularRate
              , qke :: RateCovMat
              , dt      :: Time } deriving( Show, Eq )

data MeasurmentSource = Accelerometer
                      | Magnetometer 
                      | Gyro deriving( Show, Eq )

data Measurment =
  Measurment{ source  :: MeasurmentSource
            , body    :: BodyVec
            , ref     :: RefVec
            , meascov :: MeasurmentCovMat } deriving( Show, Eq )


\end{lstlisting}

Datatypes are defined for information which is temporally associated.

\begin{lstlisting}

qzero :: Quat
qzero = [$vec| 0, 0, 0, 1|]

-- [ex]; Cross-product matrix of 3x1 column vector e, defined as
crossProdMat :: (Element a) => Vector D3 a -> Matrix (D3,D3) a
crossProdMat v = 
  [$mat| 0, -1*e3, e2 
       ; e3, 0, -1*e1 
       ; -1*e2, e1, 0 |]
  where 
  e1 = v @> 0
  e2 = v @> 1
  e3 = v @> 2

\end{lstlisting}

The \lstinline& [$mat| |] & and \lstinline& [$vec| |] & macros make it possible to construct matrices and vectors in a similar syntax to Matlab, which greatly aids readability.

\begin{lstlisting}

qre :: Quat -> Double
qre q = q @> 3

qvec :: Quat -> Vector D3 Double
qvec q = 
  [$vec| q0, q1, q2 |]
  where 
  q0 = q @> 0
  q1 = q @> 1
  q2 = q @> 2

\end{lstlisting}
The \lstinline$qre$ and \lstinline$qvec$ accessors provide a syntax that resembles that in D. Choukroun's paper.
\begin{lstlisting}
unitq :: Quat -> Quat 
unitq qq = 
  qq / constant norm 
  where 
  norm = sqrt $ (qq@>0)*(qq@>0)+(qq@>1)*(qq@>1)+
		(qq@>2)*(qq@>2)+(qq@>3)*(qq@>3)

\end{lstlisting}

Some quaternion manipulations in the Kalman filter do not produce a unit quaternion because D. Choukroun's derivations did not require unit length. To simplify the interface to the filter, we normalize a quaternion with \lstinline$unitq$.

\begin{lstlisting}
attMatOfQ :: Quat -> AttitudeMat
attMatOfQ qq = 
  liftMatrix (*constant  (q*q - e <.> e)) (ident `atRows` d3) + 
  liftMatrix (*constant 2)  (outer e e) -
  liftMatrix (*constant (2*q)) (crossProdMat e)
  where 
  q = qre qq 
  e = qvec qq

-- mulQLeftMat is the matrix Q1 of q1 where 
-- Q1<>q2 = quaternion multiplication q1*q2
mulQLeftMat :: Quat -> Matrix (D4, D4) Double
mulQLeftMat qq = [$mat| w, -z,  y,  x;
                        z,  w, -x,  y;
                       -y,  x,  w,  z;
                       -x, -y, -z,  w|]
  where w = qq @> 3; x = qq @> 0; y = qq @> 1; z = qq @> 2

-- quaternion multiplication
mulqq :: Quat -> Quat -> Quat
mulqq q1 q2 = (mulQLeftMat q1) <> q2

-- inverse quaternion: negate the axis to 
-- reverse direction of rotation
invq :: Quat -> Quat
invq qq = [$vec| -x, -y, -z, w |]
  where w = qq @> 3; x = qq @> 0; y = qq @> 1; z = qq @> 2

rad2deg :: (Floating a) => a -> a
rad2deg rads = rads * 180.0 / pi
deg2rad :: (Floating a) => a -> a
deg2rad degs = degs * pi / 180.0

\end{lstlisting}

Utility functions that should be self explanatory.

\begin{lstlisting}
-- The vecQ functions are for rotating a 
-- three-space vector by a quaternion
vecQRightMat :: Vector D3 Double -> Matrix (D4, D4) Double
vecQRightMat b = 
  ((negboX <|> bo) <-> (negbot <|> [$mat| 0 |]))
  where 
  negboX = liftMatrix (*constant (-1)) (crossProdMat b)
  bo = asColumn b
  negbot = liftMatrix (*constant (-1)) (asRow b)

vecQLeftMat :: Vector D3 Double -> Matrix (D4, D4) Double
vecQLeftMat b = 
  ((boX <|> bo) <-> (negbot <|> [$mat| 0 |]))
  where 
  boX = crossProdMat b
  bo = asColumn b
  negbot = liftMatrix (*constant (-1)) (asRow b)
\end{lstlisting}

Hmatrix-static provides operators \lstinline$<->$ and \lstinline$<|>$ to join matrices horizontally and vertically.

\begin{lstlisting}
observationMatOf :: RefVec -> BodyVec -> ObservationMat
observationMatOf r b = 
  ( (negsx <|> asColumn d) <->
    (negdt <|> [$mat|0|]) )
  where 
  s = liftVector2 (*) (constant 0.5) (b + r)
  d = liftVector2 (*) (constant 0.5) (b - r)
  negsx = liftMatrix (*constant (-1)) (crossProdMat s)
  negdt = liftMatrix (*constant (-1)) (asRow d)
\end{lstlisting}

The observation matrix (in ..., $H$) is a function of the measurement BodyVec and known RefVec.

\begin{lstlisting}
zetaMatOf :: Quat -> ZetaMat
zetaMatOf qq = 
  (ex + liftMatrix (* constant q) (ident `atRows` d3)) <-> 
  (liftMatrix (* constant (-1)) (asRow e))
  where 
  q = qre qq
  e = qvec qq
  ex = crossProdMat e

\end{lstlisting}

The matrix $\Xi$, which I ignorantly coded as ``Zeta,'' maps measurement error into the state space in the same way the matrix $H$ maps measurments into the state space.

\begin{lstlisting}
transitionMatOf :: AngularRate -> Time -> TransitionMat
transitionMatOf w dt = 
  expm omegadt
  where 
  omega = vecQRightMat w
  omegadt = liftMatrix (* constant dt) omega

\end{lstlisting}

This transition matrix is derived in ... as a matrix multiplication on a quaternion. I wanted to ensure it was equivalent to the more common derivation, and so I wrote a function below, \lstinline$transitionQuatOf$, which uses quaternion multiplication and the angle-axis method.

\begin{lstlisting}

transitionQuatOf :: AngularRate -> Time -> Quat
transitionQuatOf w dt = 
  [$vec| qx, qy, qz, qre |]
  where
  wx = w @> 0; wy = w @> 1; wz = w @> 2
  qx = sin $ wx * dt
  qy = sin $ wy * dt
  qz = sin $ wz * dt
  qre = 1 - (qx*qx + qy*qy + qz*qz)

timePropogate :: RateEstimate -> FilterState -> FilterState
timePropogate r s = 
  FilterState { q = unitq $ phi <> (q s)
              , p = phi <> (p s) <> (trans phi) + qkq }
  where 
  phi = transitionMatOf (omega r) (dt r)
  zeta = zetaMatOf (q s)
  zetat = ((dt r)/2)^2
  qkq = 
    liftMatrix (*constant zetat) (zeta <> (qke r) <> (trans zeta))

timePropogate' :: RateEstimate -> FilterState -> FilterState
timePropogate' r s = 
  FilterState { q = mulqq qomega (q s)
              , p = phi <> (p s) <> (trans phi) + qkq }
  where 
  qomega = transitionQuatOf (omega r) (dt r)
  phi = transitionMatOf (omega r) (dt r)
  zeta = zetaMatOf (q s)
  zetat = (^2) . (/2) . dt $ r
  qkq = 
    liftMatrix (*constant zetat) (zeta <> (qke r) <> (trans zeta))  

\end{lstlisting}
Two similar versions of timePropogate, the second explicitly using quaternion multiplication for propagation. This is an example which demonstrates how simple it is to modify an algorithm in Haskell.

\begin{lstlisting}

measurmentUpdate :: Measurment -> FilterState -> FilterState
measurmentUpdate m s = 
  FilterState { q = unitq $ up <> (q s)
              , p = up <> (p s) <> (trans up) +
                    k <> rq <> (trans k) }
  where 
  i4 = ident `atRows` d4
  alpha = 0.001
  h = observationMatOf (ref m) (body m)
  ht = (trans h)
  zeta = zetaMatOf (q s)
  rq = (liftMatrix (*constant 0.25) 
           (zeta <> (meascov m) <> (trans zeta))) + 
       (liftMatrix (*constant alpha) i4)
  sk = h <> (p s) <> ht + rq 
  k = (p s) <> ht <> (inv sk)  
  up = (i4 - k <> h)

\end{lstlisting}
A measurement update maps FilterState to FilterState with a Measurment. If that doesn't make nice semantic sense, I don't know what does. 

\begin{lstlisting}

rateEstimateUpdate :: Measurment -> Time -> 
                       RateEstimate -> RateEstimate
rateEstimateUpdate Measurment { source = Gyro, body = b } adt re = 
  RateEstimate { omega = (omega re) + constant k * residual
               , qke = (qke re)
               , dt = adt }
  where 
  k = 0.3
  residual = b - (omega re)

rateEstimateUpdate _ _ re = re 
\end{lstlisting}
We implement a simple \lstinline$rateEstimateUpdate$ function which is a simple low pass filter on rate gyro \lstinline$Measurement$s into a \lstinline$RateEstimate$ usable by \lstinline$timePropogate$. This same filter is used by the real implementation as well.
\begin{lstlisting}
-- rezero: initial state for rate estimate. 
rezero = 
  RateEstimate 
    { omega = [$vec|0,0,0|]
    , dt = 0.02
    , qke = liftMatrix (*constant 10) (atRows ident d3) }
fszero = 
  FilterState 
    { q = qzero
    -- p is large to account for random initial position
    , p = liftMatrix (*constant 5) (atRows ident d4) }

fnorm x = pnorm PNorm2 x
\end{lstlisting}
I provide initialized filter states in this module as well, with constants that were found to be appropriate.

\subsection{Implementation of Tests}
In order to test the quaternion Kalman filter, I wrote some Euler angle translation functions using ... in order to visualize simple rotational frames. The Euler angles have various issues that prevent them from being useful to describe filter state, the most significant of which is the condition called \emph{gimbal lock} where, at``poles'' in the spherical space, it is impossible to determine one of the three angles. An analogy of this problem using the earth's geography as a spherical space is that, from the north pole, each direction is south, and the directions of east and west cannot be determined.

I defined two modules, Eulers321 and Eulers313, which use two different conventions to describe euler angles. The derivations for each angle convention is described in ... . I have omitted code below for brevity.

We use these functions below in QkfTest to generate measurements from an Euler angle simulation of the state, and then compare the output state to the input state.

\subsubsection{Eulers321.hs}
\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
module Eulers321 where

import Numeric.LinearAlgebra.Static
import Quaternion

type Angle = Double
type RotMatrix = Matrix (D3,D3) Double
type Eulers = Vector D3 Double
type WorldAngularRate = Vector D3 Double
-- ordering is [phi, theta psi] naturally
phi :: Eulers -> Angle
phi e = e @> 0
theta :: Eulers -> Angle
theta e = e @> 1
psi :: Eulers -> Angle
psi e = e @> 2
-- For convenience:
ezero :: Eulers
ezero = [$vec|0,0,0|]

\end{lstlisting}
Excuse the following carriage returns
\begin{lstlisting}

-- Make a rotation matrix from Euler angles. Deibel (449)
matOfEulers :: Eulers -> RotMatrix
matOfEulers eulers = 
  [$mat| cphi*cthe , sphi*cpsi + cphi*sthe*spsi ,
                        sphi*spsi - cphi*sthe*cpsi 
       ;-sphi*cthe , cphi*cpsi - sphi*sthe*spsi , 
                        cphi*spsi + sphi*sthe*cpsi
       ;  sthe     ,-spsi*cthe                  , 
                        cpsi*cthe                  |]
  where
  cphi = cos . phi   $ eulers
  sphi = sin . phi   $ eulers
  cthe = cos . theta $ eulers
  sthe = sin . theta $ eulers
  cpsi = cos . psi   $ eulers
  spsi = sin . psi   $ eulers

-- Make a quaternion from Euler angles. Deibel (459),
--  except re-ordered with real component last
-- to fit type Quat convention.
qOfEulers :: Eulers -> Quat
-- omitted for brevity

-- Deibel (452)
eulersOfQ :: Quat -> Eulers
eulersOfQ q =
  [$vec| atan2 ((-2)*qq1*qq2 + 2*qq0*qq3) 
               (qq1*qq1 + qq0*qq0 - qq3*qq3 - qq2*qq2)
       , asinLimited (2*qq1*qq3 + 2*qq0*qq2)
       , atan2 ((-2)*qq2*qq3 + 2*qq0*qq1) 
               (qq3*qq3 - qq2*qq2 - qq1*qq1 + qq0*qq0) |]
  where 
  qq0 = q0 q; qq1 = q1 q; qq2 = q2 q; qq3 = q3 q
  asinLimited x = if (abs x) < 1.0 
                    then asin x 
                    else asin (signum x) 
              -- v small numeric overflows: 
              -- keep args to asin in [-1,1]

-- Euler Angle Rate Matrix
-- omega = E(u) * udot  where omega is body fixed angular rates, u is Euler angles
-- Deibel (453)
type Emat = Matrix (D3,D3) Double
-- Deibel (453)
ematOfEulers :: Eulers -> Emat
-- omited for brevity
\end{lstlisting}

\subsubsection{QkfTest.hs}

\begin{lstlisting}
module QkfTest where
import Control.Monad
import Control.Concurrent
import System.Random
import Numeric.LinearAlgebra.Static
import Graphics.Gnuplot.Simple
-- Project Modules:
import Quaternion
import Eulers321
import Qkf

\end{lstlisting}
The to Measurement functions are used to simulate a measurement given Euler angles. \lstinline$matOfEulers$ produces a rotation matrix, \lstinline$ematOfEulers$ transforms the global derivatives of Euler angles into the body frame. 
\begin{lstlisting}

-- Measurement functions: generate a filter input from Euler angles
toVecMeasurment :: MeasurmentSource -> RefVec -> Eulers -> Measurment
toVecMeasurment s r e = 
  Measurment{ source = s
            , body = (matOfEulers e) <> r
            , ref = r
            , meascov = 
                liftMatrix (* constant 0.00001) (atRows ident d3) }

toAccMeasurment = toVecMeasurment Accelerometer [$vec|0,0,-1|] 
toMagMeasurment = toVecMeasurment Magnetometer [$vec|1,0,0|] 

toGyroMeasurment :: Eulers -> WorldAngularRate-> Measurment
toGyroMeasurment e edot = 
  Measurment { source = Gyro
             , body = (inv $ ematOfEulers e) <> edot 
             , ref = [$vec|0,0,0|]
             , meascov = 
                 liftMatrix (* constant 0.01) (atRows ident d3) }

\end{lstlisting}
\lstinline$generateWalk$ is a good example of a Haskell operation on lists. Given an initial Euler angle, a list of derivatives, and the simulation time between elements in the derivative list, it will produce a list of eulers.
\begin{lstlisting}

-- given: initial Euler angles, list of derivatives, 
-- time step between derivatives
-- produces: list of resulting Euler angles
generateWalk :: Eulers -> [WorldAngularRate]-> Time -> [Eulers]
generateWalk e (edot:edots) dt = (e:es)
                  where e' = advanceConst e edot dt
                        es = generateWalk e' edots dt
generateWalk _ [] _ = []

\end{lstlisting}

\lstinline$feedfilter$ takes a time step, a list of the simulated measurments, and a tuple of the two filter states. It produces a list of resulting filter states. 

\begin{lstlisting}
feedfilter :: Time -> [(Measurment, Measurment, Measurment)] -> 
               (FilterState, RateEstimate) -> 
               [(FilterState, RateEstimate)]
feedfilter dt ((ma, mm, mg):ms) (state,rate) = 
  ((state,rate):states)
  where 
    s'acc = measurmentUpdate ma state
    s'mag = measurmentUpdate mm s'acc
    rate' = rateEstimateUpdate mg dt rate
    s'gyro = timePropogate rate' s'mag
    states = feedfilter dt ms (s'gyro, rate')
\end{lstlisting}

\lstinline$statictest$ implements test commonly referred to as the ``unit step,'' where the filter is given a steady state input at t=0 to test convergence from the initial value. This function has the filter seek \lstinline$e$ = $(\pi/4, \pi/3, 0)$. f

\begin{lstlisting}
statictest = do
  let e = [$vec| pi/4, pi/3, 0 |] :: Eulers
  let edot = [$vec| 0,0,0 |]
  let f = feedfilter 0.05 
           (repeat 
             ( toAccMeasurment e
             , toMagMeasurment e
             , toGyroMeasurment e edot)) 
           (fszero, rezero)
  plotLists [] $ (stateqs $ take 10 f) ++ 
    (justqs $ take 10 $ repeat $ qOfEulers e)
  let q10th =  q . fst . last . take 10 $ f
  putStrLn "Filtered quaternion after 10 iterations:"
  putStrLn $ show q10th
  putStrLn "Theoretical static quaternion:"
  putStrLn $ show $ qOfEulers e
  putStrLn "Supplied set of angles"
  putStrLn $ show e
  putStrLn "Set of angles derived from filtered quaternion"
  putStrLn $ show $ eulersOfQ q10th

velocitytest = do
  let einit = [$vec| pi/4, pi/3, 0 |] :: Eulers
  let edot = [$vec|pi/3, -pi/12, 0|] :: WorldAngularRate
  let edots = (replicate 10 [$vec|0,0,0|]) ++ 
              (replicate 25 edot) ++ 
              repeat [$vec|0,0,0|]
  let dt = 0.05 -- 20hz
  let walk = generateWalk einit edots dt
 
  let f = feedfilter' dt (meas walk edots) (fszero, rezero) 
  let fs = take 50 f
  let ws = take 50 walk

  plotQuaternions ws fs
  plotEulers ws fs
\end{lstlisting}

It would be nice to plot, as in Matlab, to examine the filter input and output. Using the \lstinline$Graphics.Gnuplot.Simple$ library\footnote{\lstinline$Graphics.Gnuplot.Simple$ is a simple interface to the \lstinline$Graphics.Gnuplot$ library, distributed on hackage as the \emph{gnuplot} package. \url{http://hackage.haskell.org/package/gnuplot}}, we can examine our results immediately after execution. 

These functions might be the weakest point of comparison to Matlab, as they're quite verbose in order to fully customize the graph before plotting. There is also a library bug which prevents plots from being labeled. This portion of the project leaves room for future improvement, but gets the job done.

\begin{lstlisting}
plotQuaternions walks filters =
  let (fq0,fq1,fq2,fq3) = stateqTs filters
      (wq0,wq1,wq2,wq3) = justqTs $ map qOfEulers walks
      wtype = Lines
      ftype = Points
  in plotListsStyle [ Title "Quat Components" ]
                   {- , Key (Just [ "Input qre","Output qre"
                                , "Input qx","Output qx"
                                , "Input qy","Output qy"
                                , "Input qz","Output qz"]) 
                    -- Gnuplot Interface Broken -}
      [ (PlotStyle wtype (DefaultStyle 4), wq0)
      , (PlotStyle ftype (DefaultStyle 4), fq0) 
      , (PlotStyle wtype (DefaultStyle 1), wq1)
      , (PlotStyle ftype (DefaultStyle 1), fq1)
      , (PlotStyle wtype (DefaultStyle 2), wq2)
      , (PlotStyle ftype (DefaultStyle 2), fq2)
      , (PlotStyle wtype (DefaultStyle 3), wq3)
      , (PlotStyle ftype (DefaultStyle 3), fq3)]
                                                      
plotEulers walks filters =
  let (fa1, fa2, fa3) = stateangleTs filters
      (wa1, wa2, wa3) = angleTs walks
      wtype = Lines
      ftype = Points
  in plotListsStyle [ Title "Euler Angles" ]
     [ (PlotStyle wtype (DefaultStyle 1), wa1)
     , (PlotStyle ftype (DefaultStyle 1), fa1)
     , (PlotStyle wtype (DefaultStyle 2), wa2)
     , (PlotStyle ftype (DefaultStyle 2), fa2)
     , (PlotStyle wtype (DefaultStyle 3), wa3)
     , (PlotStyle ftype (DefaultStyle 3), fa3) ]
\end{lstlisting}

\subsection{Sensor Interface}
\subsubsection{SerialQKF.hs}
It is pretty easy to use serial ports in Haskell. \lstinline$System.Hardware.Serialport$\footnote{On Hackage, the \emph{serialport} package: \url{http://hackage.haskell.org/package/serialpot/}} provides full access to the baud settings and extra signals on my FT232-based USB to Serial converter.
\begin{lstlisting}
module SerialQKF where
import System.Hardware.Serialport
import Control.Monad hiding (forM, forM_)
import Data.Foldable
import Control.Monad.Loops
import Control.Concurrent
import Numeric.LinearAlgebra.Static
import Qkf

serialBegin :: IO SerialPort
serialBegin = do
  s <- openSerial "/dev/ftdi5" defaultSerialSettings 
                                { baudRate = B115200 }
  -- next 3 lines: toggle reset on Arduino
  setDTR s False
  threadDelay 500000
  setDTR s True
  return s

\end{lstlisting}

A \lstinline$SerialPort$'s \lstinline$getChar$ equivelant is \\\lstinline$recvChar :: SerialPort -> IO (Maybe Char)$. The IO is of \lstinline$Maybe Char$ to support a timeout of the \lstinline$recvChar$ call. 

\lstinline$recvChar$ is used here to build a function that returns full lines. Perhaps \lstinline$recvLine$ would have been a better name. It is built based on the \lstinline$getLine$ function described in ... .

\begin{lstlisting}
-- from Tackling the Awkward Squad 
getLineMaybe :: SerialPort -> IO [Char] 
getLineMaybe s = do 
  c <- recvChar s;
  case c of
    Just '\n' -> return []
    Just a    -> do { cs <- getLineMaybe s;
                            return (a:cs) }
    Nothing   -> do { cs <- getLineMaybe s;
                            return(cs) }
       
\end{lstlisting}
Omitted for brevity:
There is some parsing code which converts the line into a \lstinline$Measurment$. 
There is some calibration code that applies a predetermined offset and scale to a \lstinline$Measurment$ based on its source.
There is also a utility that prints the running minimum and maximum magnetometer and accelerometer measurments to the screen. This is useful to for determining the scale and offset for each axis, by rotating the sensor through the minimum and maximum points for each axis. 

Parsed and calibrated \lstinline$Measurment$s are sent to other Haskell threads using \lstinline$Control.Concurrent$'s \lstinline$SampleVar$ interface. A \lstinline$SampleVar$ works as follows: a value can be written at anytime from any thread. If the variable is `empty,' a write `fills' it. If the variable is already `full,' a write overwrites the current value. A read can also be initiated at any time from any thread. If the variable is empty, the read will block until the variable becomes full, and then behave as a `filled' read. When the variable is `filled,' a read `empties' it. 

\begin{lstlisting}
sampleCalibrated :: (SampleVar Measurment, SampleVar Measurment, 
                      SampleVar Measurment) -> IO ()
sampleCalibrated (acccal, magcal, gyrocal) = do
  s <- serialBegin
  forever $ do
    l <- getLineMaybe s
    forM_ (parseLine l) $
      \parsed -> 
        let calibrated = offsetandscale parsed in
        case calibrated of 
          CM Accelerometer _ _ _ ->  
            writeSampleVar  acccal calibrated
          CM Magnetometer _ _ _  ->  
            writeSampleVar  magcal calibrated
          CM Gyro _ _ _          ->  
            writeSampleVar gyrocal calibrated
    threadDelay 50
\end{lstlisting}

\lstinline$SampleVar$s are used here to ensure that the filter (reading) thread always operates on the most recent of each measurement, by making a separate \lstinline$SampleVar$ for each measurement. The filter thread will not be able to proceed until an entire new set of measurements are available.

\subsection{OpenGL Demonstration Interface}

For an effective demonstration of the filter's real-time performance with the sensor attached, I used the HOpenGL library's bindings to OpenGL and the OpenGL Utility Toolkit (GLUT). I reused some example code found online to render a cube on the screen, and hooked it into the filter using another \lstinline$SampleVar$. I won't list the OpenGL here for brevity, but it can be found in Cube.hs. Here is the interprocess communication setup code:

\subsubsection{runsensor.hs}
\begin{lstlisting}
import Numeric.LinearAlgebra.Static
import Control.Concurrent
import Qkf
import QkfTest
import Cube
import SerialQKF
import Graphics.Gnuplot.Simple

type CalSampleVar = SampleVar CalibratedMeasurment
type ThreeCalSamples = (CalSampleVar, CalSampleVar, CalSampleVar)
type KFilter = (FilterState, RateEstimate)
type ThreeMeas = (Measurment, Measurment, Measurment)
type ThreeCals = (CalibratedMeasurment, CalibratedMeasurment, CalibratedMeasurment)

main = do
  acccal   <- newEmptySampleVar
  magcal   <- newEmptySampleVar
  gyrocal  <- newEmptySampleVar
  filtered <- newEmptySampleVar
  reslog <- newChan

  t1 <- forkIO $ sampleCalibrated (acccal, magcal, gyrocal)
  t2 <- forkIO $ loopAndSend filtered 
			     (filterSamples (acccal, magcal, gyrocal)) 
			     (fszero, rezero) reslog
  forkIO $ cubewith filtered >> killThread t1 >> killThread t2
  plotresults reslog

filterSamples :: ThreeCalSamples -> KFilter ->  IO (KFilter, ThreeMeas)
filterSamples (acccal, magcal, gyrocal) (fstate, rstate) = 
 let dt = 0.03 in
 do
  latestacc <- readSampleVar acccal
  latestmag <- readSampleVar magcal
  latestgyro <- readSampleVar gyrocal
  let acc = accMeasurment latestacc
  let mag = magMeasurment latestmag latestacc
  let gyro = gyroMeasurment latestgyro  
  let fs'acc = measurmentUpdate acc fstate
  let fs'mag = measurmentUpdate mag fs'acc
  let rstate' = rateEstimateUpdate gyro dt rstate
  let fs'gyro = timePropogate rstate' fs'mag
  
  return ((fs'gyro, rstate'), (acc, mag, gyro))

\end{lstlisting}

\subsection{Paparazzi Autopilot Interface}
I have not yet completed an interface to another C process. This will require interprocess communication, most likely through the Linux Message Queue (mq) system.

\section{Results}

I managed to use Haskell to achieve soft real-time without resorting to C, and was able to simulate and visualize my algorithm with the ease and power normally associated with Matlab. Haskell allowed me to test the filter with both 2D plots and real-time 3D rendering with both simulated data and sensor data.

\subsection{Noise-free simulated measurements}
Plots of step test, ramp test
\subsection{Noisy simulated measurements}
step test, ramp test
\subsection{Tests with Sensor}
\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{./youtube-screenshot.png}
  \caption{A still from video of an OpenGL demonstration of the sensor. Video available at http://bit.ly/pch-qkf-video}
\end{figure}

\end{document}


