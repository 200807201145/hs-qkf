\documentclass[12pt]{report}
\usepackage[pdftex]{graphicx}
\usepackage{url}
\usepackage{amsmath}
\usepackage{listings}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor auto-nomous}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Design of an Attitude and Heading Reference Sensor}
\author{Patrick Hickey\\pat@moreproductive.org}
\input{./title.tex}

\begin{abstract}
This paper describes the design of an Attitude and Heading Reference Sensor (AHRS), which measures rootational orientation relative to north and down. 
The design uses 3-axis accellerometer, magnetometer, and rate gyro sensors. 
I will discuss the selection and construction of the sensor hardware, design and implementation of a Kalman filter for sensor fusion, and the test of both the sensor hardware and software.
\end{abstract}


\section{Problem Description}

The goal of this project was to design and build sensor hardware and software that would determine the angular orientation and angular rotation rate of the sensor relative to the earth frame, ie. North, East, and Down. I selected sensor integrated circuits (ICs) which determine, on three axes, body accelleration, body rotation rate, and relative magnetic field. These three sensors (accellerometer, rate gyro, and magnetometer) provide a total of nine measurments. 

An algorithm is required to convert these nine measurments into an expression of angular orientation and angular rate (the derivative, with respect to time, of angular orientation). Angular orientation of a body has three degrees of freedom, as does angular rate. The conversion from measurment space to estimate space (a pair of angular orientation estimate and angular rate estimate) is nonlinear and uses a four-dimensional vector called a quaternion to describe the three-dimensional angular orientation. This is to say, a big part of the problem is ensuring the correctness of this difficult conversion process.   

I selected a well-known algorithm which implements a Quaternion Kalman Filter. This provides an state estimate using the four-dimensional quaternion vector, and an additional three-dimensional rotational rate vector. I needed to implement that software so that I could test it for correctness and use it to determine the orientation of an actual sensor. This software was to be used in an actual model aircraft autopilot system, so it must meet requirments for reliability and soft real-time performance.

\subsection{Application}

As part of my role on the Rutgers Autonomous Aircraft Team, I've been working on a model aircraft autopilot system based on a single board computer which runs Linux \footnote{For more information on this project, see \url{http://moreproductive.org/autopilot/}}. I implemented the control, navigation, and telemetry software in C using standard Linux system calls and threads. I used dedicated hardware for real-time tasks, for example, a microcontroller-based servo controller connected via USB ensures proper servo control despite irregular communication intervals from the computer. 
By using helper threads for input and output, we can be reasonably sure the main control loop will run at close to 60Hz. This is considered ``soft'' real-time.

The sensor software needs to cooperate with the soft real-time main control loop. In order to stabilize a fixed-wing aircraft, we need to update the main control loop's orientation estimate at at least 30Hz, preferably at 60Hz. So the sensor hardware must provide new measurments at a rate exceeding 30Hz, a complete measurment every 33ms. The sensor filtration software must complete computation in much less than a measurment period as not to dominate the CPU. Lets consider a target time of 500us per computation.

\subsection{Use of Haskell}

The sensor software I describe in this paper is typically implemented in a low level language such as C or C++ in order to give the programmer explicit control over memory allocation and input-output (IO) calls. In fact, open source implementations of functionally similar software is available. 

I decided to write the filter software using Haskell. Haskell is a purely functional language with a powerful type system, and is not typically used for soft real-time applications. However, I believe Haskell is well suited for writing algorithms because it can express mathematical concepts elegantly, and often transparently. It is often possible to reason about Haskell code in the exact same way as mathematics. This results in code which is code more readable and more easily modified. 

\section{Theoretical Basis}

The theoretical basis for this paper has been primarily drawn from -- cite dchoukrouns paper. I hope this section provides a clear explanation of how that theory applies to this project.

\subsection{Measurment Vectors}
Because the sensors are fixed to the frame (\emph{body}) we're estimating the orientation, accellerometer and magnetometer provide us with vector measurments in the body frame. We denote body frame vectors with $b_x$. The expecte vector of that measurment in the global frame is $g_x$. For example, the expected global frame accelleration $g_a = \begin{bmatrix} 0 & 0 & -1\end{bmatrix} $ in units normalized to $1g$ ($9.81m/s^2$)

By comparing a body frame vector to the global frame vector, we can find a rotation which transforms the global frame into the body frame. We call this the orientation estimate.  

\subsubsection{Accellerometer Measurment}

An accellerometer measures force exerted by a small test mass against a beam connected to the sensor body. The current generation of MEMS accellerometers uses etched silicon to build the test mass and beam structure, and measures the capicatance between the test mass and sensor body to determine the beam deflection. Since an accellerometer can only measure deflection, and therefore accelleration, in one direction, we use three separate sensors oriented to measure accelleration along three orthogonal axes. These three separate measured accellerations ($a_x, a_y, a_z$) can be considered as a three dimensional vector 
\begin{equation} \label{eq:defa}
  a = \begin{bmatrix}a_x&a_y&a_z \end{bmatrix}
\end{equation}

According to Newton's second law, $F = m a$ , the force on a body will be directly proportional to the accelleration of the body. When we consider a small test mass $m_t$ on a beam, and the system is at rest, the mass will exert a force $F_g = m_t g_b$, where $g$ is the accelleration due to gravity in the body frame. A body accelleration ab will exert a force $F_a = m_t a_b$. The sensor measures the sum of these two forces, so for any $F = F_g + F_a = m_t ( g_b + a_b )$. Because $m_t$ is constant, we can define the scaled measurment $a$ as 
\begin{equation} \label{eq:defza}
  a = \frac{F}{m_t} = g_b + a_b
\end{equation} 
 
In this application we're interesting in estimating $b_a$ in order to find the vector, in the body frame, which points straight down in the world frame. We include a measurment noise vector $\delta_a$, and find measurment $z_b$ as
\begin{equation} \label{eq:findgb}
  z_a = b_a + a_b + \delta_a
\end{equation}

On a body such as an aircraft, where accellerations $a_b$ may come from any direction at any time, we consider $a_b$ to be a zero-mean gaussian random vector with a covariance matrix 
\begin{equation} \label{eq:Qa}
  Q_a = \begin{pmatrix} \sigma_a^2 & 0 & 0 \\
	                      0 & \sigma_a^2 & 0 \\ 
	                      0 & 0 & \sigma_a^2 \end{pmatrix} 
\end{equation}

Covariance matrix $Q_a$ will be used in the measurment model of the Kalman Filter. We typically estimate a value for $\sigma_a$ to be between 2$g$ and 4$g$ for airborne applications. Since $\delta_a$ will be zero-mean and have a small variance compared to $a_b$ we can neglect it.

\subsubsection{Magnetometer Measurment}

A magnetometer measures the magnitude magnetic field in one direction. I refer the interested reader to ... for a physical explanation of magnetometer sensors. The three separate measured magnetic field magnitudes ($m_x, m_y, m_z$) are considered as a three dimensional vector
\begin{equation} \label{eq:defb}
  m = \begin{bmatrix} m_x & m_y & m_z \end{bmatrix}
\end{equation}

The measured magnetic field $z_m$ will be the sum of three vectors: the natural magnetic field of the earth in the body frame $b_m$, the magnetic field of the body $m_s$, and measurment noise $\delta_m$.
\begin{equation} \label{eq:zm}
  z_m = b_m + m_s + \delta_m
\end{equation}
In this filter we assume the magnetic field of the body $m_s$ to be constant\footnote{Electrical and mechanical components which emit a changing electromagnetic field, such as DC motors and switching power supplies, will cause trouble.}. We will estimate $m_s$ for the particular body the sensor is installed in. Measurment noise $\delta_m$ will be considered a zero-mean gaussian random vector with covariance matrix
\begin{equation} \label{eq:Qm}
  Q_m = \begin{pmatrix} \sigma_m^2 & 0 & 0 \\
	                      0 & \sigma_m^2 & 0 \\ 
	                      0 & 0 & \sigma_m^2 \end{pmatrix} 
\end{equation}

We will estimate $\sigma_m$ from a long sequence of samples taken with the filter hardware at rest.

The earth's magnetic field, in the global frame ($g_m$), will point towards magnetic north when projected onto a horizontal plane. (talk about magnetic field strength, magnetic declination angle here)


\subsubsection{Rate Gyro Measurment}

A rate gyro measures the rotation rate of a body about a single axis. We use three orthogonal rate gyros to estimate the rotational rate of the body, considered as a vector
\begin{equation} \label{eq:omega}
	\omega = \begin{bmatrix} \omega_x & \omega_y & \omega_z \end{bmatrix}
\end{equation}
The measurment $z_\omega$ can be considered as
\begin{equation} \label{eq:zomega}
	z_\omega = \omega + \Delta_\omega + \delta_\omega
\end{equation}
where rate gyro zero offset $\Delta_\omega$ is the constant vector output when the sensor body is at rest,
and measurment noise $\delta_\omega$ is a zero-mean gaussian random vector with covariance matrix
\begin{equation} \label{eq:Qomega}
	Q_\omega = \begin{pmatrix} \sigma_\omega^2 & 0 & 0 \\
	                  ]    0 & \sigma_\omega^2 & 0 \\ 
	                      0 & 0 & \sigma_\omega^2 \end{pmatrix} 
\end{equation}

In reality, zero offset $\Delta_\omega$ may drift with time and change in temperature. Compensation for this gyro drift is outside the scope of this paper, but has been solved in --cite dchokrouns better paper.

\subsection{Quaternion Representation}

There are a wide variety of resources which formally describe quaternions and their use in describing spatial rotations. I will give an overview of the most useful properties which will be used in this work.

A quaternion is a complex number with three imaginary components, $i,j,k$, which are defined such that $i^2 = j^2 = k^2 = ijk = -1$. Quaternions span a four-dimensional real-numbered space where a quaternion $a + b i + c j + d k$ can be considered as a vector $\begin{bmatrix}a & b & c & d \end{bmatrix}$. 

Quaternion multiplication is a noncommutative operation: $q_1 q_2$ is not equal to $q_2 q_1$ for all quaternions $q_1, q_2$. This property is useful because spatial rotation is a noncommutative operation as well.

The set of unit quaternions, all $q$ where $ ||q|| = 1$, are used to represent spatial rotations. For every unit quaternion $q$ 
there exists a unit vector $\mathbf{v} = \begin{bmatrix} v_x & v_y & v_z \end{bmatrix}, ||v|| = 1$ 
and an angle $\theta \in [-\pi, \pi]$ where 
$q = \begin{bmatrix} \cos (\theta/2) & v_x \sin (\theta/2) & v_y \sin (\theta/2) & v_z \sin (\theta/2)\end{bmatrix}$. The quaternion formed in this represents a spatial rotation about axis $\mathbf{v}$ of angle $\theta$. 
From this angle-axis notation, we can see that $q$ and $-q$ represent the same spatial rotation. 

The inverse quaternion $q^{-1} = a - bi - cj - dk$ of a unit quaternion $q$ represents the inverse rotation $q$. We can visualize this as the same angle of rotation $\theta$ about an inverted axis $\mathbf{v}$.

I refer the reader to --citations for more detailed information.

\section{Hardware}
\subsection{Sensors}
In order to simplify the design of the sensor module, I selected two digital ICs which contain all of the sensing elements and analog to digital interfaces onboard. 
Both digital devices selected require no external passive or active components aside from bypass capicators. Analog sensors, by comparison, often require several amplifier and filter components per channel, and often, for high resolution sensing applications, a discrete analog to digital converter (ADC) IC. In addition, analog ICs generally require an isolated ``quiet'' power and ground from digital ICs. 

\subsubsection{Three-axis Accellerometer and Magnetometer}
ST Micro's LSM303DLH, a three-axis accellerometer and magnetometer, was selected for this project. A single 6x6mm surface mount package contains both an accellerometer and magnetometer module, each with their own analog to digital converters and two-wire (I2C) serial interface. 

The three-axis accellerometer has a maximum range of ... and ... bits (... g) of resolution. The maximum sample rate is ... samples per second.

The accellerometer module includes a self-test functionality, which ...
I've implemented a boot time self-test in the embedded code.

The three-axis magnetometer has a maximum measurment range of  and ... bits (... unit) of resulution. The maximum sample rate is ... samples per second. 

The magnetometer module includes a self-test functionality, which ...
I've implemented a boot time self-test in the embedded code.

The LSM303DLH is presently (May 2010) unreleased by ST Micro. I would like to thank ST Micro for donating an evaluation board to my project. The evaluation board provided 0.1" pitch headers, and connected both the accellerometer and magnetometer module's I2C bus to a common pair of pins. It also provides a configurable interrupt output pin for both the accellerometer and magnetometer module. The board takes 3.3v power and ground.

% should include a photograph, citation

\subsubsection{Three-axis Rate Gyro}

Invensense's ITG-3200, a three-axis rate gyro, was selected for this project. A 4x4mm surface mount package contains three gyro axes, analog to digital converters, and a two-wire (I2C) serial interface. It has a full scale range of $\pm 2000$ degrees per second (deg/s) and 16 bits (14.375 LSB/deg/s) of resolution. The maximum sample rate is ... samples per second. Because the rate gyro is a MEMS device, it is important that the device is isolated from severe shocks, such as drops, which could cause internal damage.

The ITG-3200 was released by Invensense in April 2010 and is presently their flagship digital sensor. I would like to thank Invensense for donating an evaluation board to my project. The ITG-3200 was provided on an evaluation board with 0.1" pitch headers. It requires a pair of signals for I2C, an optional interrupt output signal, and 3.3v power and ground. The optional interrupt output signal can be configured to signal when an analog to digital conversion is complete.

% should include a photograph, citation

\subsection{Microcontroller}
A microcontroller was required to interface with the three sensor modules on a single I2C bus, perform boot-time configuration and self-test, and transfer measurments to a PC. I selected a Sparkfun Arduino Pro Mini board, a small 0.1" pitch pin header breakout board based on a 3.3v Atmel AtMega328 microcontroller. The AtMega328 provides a single UART and single I2C peripheral. 

The sensor board connects to the host computer with an FTDI serial to USB converter. The FTDI converter also provides 3.3v power to the board.

% should include a photograph, citation

\subsection{Construction}

Because each sensor evaluation board used 0.1" pitch pins, I was able to use a 0.1" pitch protoboard and female pin headers to build a prototype sensor. The assembled sensor prototype is 2.5" x 4.5" x 0.75" in outer dimensions. To prevent electrostatic discharge and physical damage, it is velcroed inside a protective cardboard box with a lining of stiff anti-static foam. 

% picture

A schematic drawing is provided in the appendix. % do this

\lstset{language=C++,basicstyle=\ttfamily}
\section{Embedded Software}
The code described in this section can be found at \url{http://github.com/pchickey/p4l-ahrs}. It is built using the open source Arduino IDE, which can be found at \url{http://arduino.cc}.

\subsection{Requirments}
The embedded software primarily needs to send the measurments read from the I2C bus to the host computer on its 
UART\footnote{Universal Asynchronous Receive and Transmit; the receive/transmit method used by many serial protocols including RS232} 
interface. Each sensor has a number of configuration registers which are accessed through the I2C interface which need to be 

\subsection{Sensor Communication}

The communication protocol for each sensor is best detailed in their datasheet, and I will not discuss them in depth here. The basic unit of interface is register read and register write. Some registers (for example, the latest measurment) are read-only, and reads may effect the state of the device. For example, a read of a register measurment on the ITG-3200 will clear the ``new measurment available'' flag on another register.   

Read Register and Write Register commands both block for nontrivial amounts of time.
\lstset{language=C++,basicstyle=\ttfamily}
From i2c_registers.pde
\begin{lstlisting}
#include <Wire.h>
char i2cReadRegister(int i2c_device, char i2c_register)
{
  Wire.beginTransmission(i2c_device);
  Wire.send(i2c_register);
  Wire.endTransmission();
  Wire.requestFrom(i2c_device, 1);
  return Wire.receive();  
}

void i2cReadRegisterSequential(int i2c_device, char i2c_register, 
        int len, char * buf)
{
  Wire.beginTransmission(i2c_device);
  Wire.send(i2c_register);
  Wire.endTransmission();
  Wire.requestFrom(i2c_device, len);
  int ii;
  for(ii = 0; ii < len; ii++)
    buf[ii] = Wire.receive();
  return;
}
void i2cWriteRegister(int i2c_device, char i2c_register, char value)
{
  Wire.beginTransmission(i2c_device);
  Wire.send(i2c_register);
  Wire.send(value);
  Wire.endTransmission();
}  
\end{lstlisting}

The \lstinline$Wire$ library is provided by the Arduino IDE.  The \lstinline$Wire$ object is instantiated as the interface to the single I2C peripheral\footnote{For more information on the I2C bus, see ...} on the AtMega chip. The peripheral will control the bus state and provide byte-at-a-time synchronous transmit and receive. 

Note that \lstinline$beginTransmission(int)$, \lstinline$send(char)$, and \lstinline$requestFrom(int, int)$ only return after 8 bits have been sent on the I2C bus. At a bitrate of 100kHz we can expect this to take 80$\mu$s (0.08ms). A call to \lstinline$receive()$ will not return until one byte has been received on the bus. If the slave device responds immediately, this will only take 80$mu$s, but could possibly take longer if the slave device misbehaves and holds the bus in ``wait to receive'' state.
\begin{lstlisting}
void i2cWriteWithCheck(int i2c_device, char i2c_register, 
        char value, char* name)
{
  i2cWriteRegister(i2c_device, i2c_register, value);
  char check = i2cReadRegister(i2c_device, i2c_register);
  if (check != value)
  {
    Serial.print("$DEBUG,");
    Serial.print(name);
    Serial.print(" config appears unsuccessful.");
    Serial.print("expected ");
    Serial.print(int(value));
    Serial.print(" read ");
    Serial.println(int(check));
  }
}
\end{lstlisting}
In the boot configuration of sensors, I use a wrapper on \lstinline$i2cWriteRegister$ which confirms a write was successful. Unsuccessful writes usually indicate the sensor is malfunctioning.

% calculate best-case blocking time based on bus bitrate (100kbps?)

\subsection{Host Computer Communication}
A simple serial protocol, based on NMEA-style sentences (cite), is defined for communication with the host computer. 

\subsection{Arduino Environment}
The Arduino environment is an IDE, C/C++ compiler, and collection of libraries for AtMega328 and similar Atmel AVR microcontrollers. It provides a high level interface to the hardware and is suitable for rapid prototype development. 

The timing and logic requirments of the I2C and UART interfaces are handled in hardware, and the Arduino environment provides a library for blocking read and write operations on both of these interfaces. 

On reset\footnote{The most common way to program AVR and similar microcontrollers is unsupervised by any kernel, therefore ``bare metal''. Essentially, on power on a bootloader checks for new firmware over the serial port, and if none is found, passes control to a single entry point. The C linker will choose \lstinline$main()$ unless told otherwise. This bare metal code can only be superceded by interrupt service routines.}
, the Arduino environment will intitialize and call \lstinline$void setup()$. This code runs once and should setup all of the interfaces which will remain the same throughout execution. The setup code then initializes the configuration registers of the sensor devices, performs sanity checks of those registers to ensure successful writes, and performs the self-test of the magnetometer and accellerometer device. 

% listing here

Once the \lstinline$setup$ routine has returned, the Arduino environment will call \lstinline$void loop()$ in an endless loop. This code performs reads of any available sensor measurment, and prints the result to the serial port.

% listing here

In this code, many operations involve serial reads and writes which block for significant amounts of time. The (... check new) calls actually read registers on the sensor device, which takes a nontrivial amount of time. 



describe arduino programming environment
blocking serial calls
-- Provide timing information?

\section{Filtration Software}
The filtration software was implemented in Haskell. The code may be found on Github at \url{http://github.com/pchickey/hs-qkf/}
\lstset{language=Haskell}
\subsection{Algorithm Selection}
find an algorithm which assumes my measurment sources
\subsection{Implementation of Filter}
hmatrix-static
quaternions
\subsection{Implementation of Tests}
euler models
rotation-matrix based vector measurment simulation
addition of noise
\subsection{Sensor Interface}
serial.hs
\subsection{Gnuplot Interface}
overview, code snippets
\subsection{OpenGL Demonstration Interface}
cube.hs overview, code snippets 
\subsection{Paparazzi Autopilot Interface}
ffi, linux mq
"ongoing investigation"

\section{Results}
\subsection{Noise-free simulated measurments}
Plots of step test, ramp test
\subsection{Noisy simulated measurments}
step test, ramp test
\subsection{Tests with Sensor}
plots, link to video on youtube

\end{document}


